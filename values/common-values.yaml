database:
  type: postgresql
  url: "jdbc:postgresql://###ZARF_VAR_CONFLUENCE_DB_ENDPOINT###:5432/###ZARF_VAR_CONFLUENCE_DB_NAME###"
  driver: org.postgresql.Driver
  credentials:
    secretName: confluence-postgres
    usernameSecretKey: username
    passwordSecretKey: password

monitoring:
  exposeJmxMetrics: true
  jmxExporterInitContainer:
    runAsRoot: false

volumes:
  localHome:
    persistentVolumeClaim:
      create: true
      # storageClassName: your-storage-class-here
      resources:
        requests:
          storage: 10Gi
  sharedHome:
    persistentVolumeClaim:
      create: true  # To enable clustering
      resources:
        requests:
          storage: 10Gi
    nfsPermissionFixer:
      enabled: false

ingress:
  nginx: false

serviceAccount:
  create: true
  name: confluence
  role:
    create: true

   # Define permissions
   # https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole
   #
  clusterRole:

    # -- Set to 'true' if a ClusterRole should be created, or 'false' if it
    # already exists.
    #
    create: true

    # -- The name of the ClusterRole to be used. If not specified, but
    # the "serviceAccount.clusterRole.create" flag is set to 'true',
    # then the ClusterRole name will be auto-generated.
    #
    name: confluence

confluence:
  service:
    type: ClusterIP  # Use this whether doing a standalone server or a clustered setup
  hazelcastService:
    enabled: true
  clustering:
    enabled: true
  tomcatConfig:
    generateByHelm: true
  seraphConfig:
    generateByHelm: true
  resources:
    container:
      requests:
        cpu: "2"
        memory: "4Gi"
      limits:
        cpu: "4"
        memory: "8Gi"
    jvm:
      minHeap: "2g"
      maxHeap: "4g"

  securityContext:
    fsGroup: 2002
    runAsNonRoot: true
    runAsUser: 2002
    runAsGroup: 2002
  containerSecurityContext:
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    runAsUser: 2002
    runAsGroup: 2002

# replicaCount: 1 - bring this up manually, one-by-one.

# TODO: get Synchrony's clustering setup too

  # At minimum we support v1.2, may change to support only v1.3: https://github.com/defenseunicorns/uds-core/blob/main/src/istio/chart/values.yaml#L28
  additionalJvmArgs:
    # Prevent TLS reduction to v1.1
    - "-Dhttps.protocols=TLSv1.2,TLSv1.3"
    # These additional Args avoid warnings from Hazelcast.
    - "--add-modules java.se"
    - "--add-exports java.base/jdk.internal.ref=ALL-UNNAMED"
    - "--add-opens java.base/java.lang=ALL-UNNAMED"
    - "--add-opens java.base/java.nio=ALL-UNNAMED"
    - "--add-opens java.base/sun.nio.ch=ALL-UNNAMED"
    - "--add-opens java.management/sun.management=ALL-UNNAMED"
    - "--add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED"

openshift:
  # -- When set to true, the containers will run with a restricted Security Context Constraint (SCC).
  # See: https://docs.openshift.com/container-platform/4.14/authentication/managing-security-context-constraints.html
  # This configuration property unsets pod's SecurityContext, nfs-fixer init container (which runs as root), and mounts server
  # configuration files as ConfigMaps.
  #
  # Lesson Learned: DO NOT ENABLE THIS - it is DOA
  runWithRestrictedSCC: false
