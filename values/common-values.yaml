database:
  type: postgresql
  url: "jdbc:postgresql://###ZARF_VAR_CONFLUENCE_DB_ENDPOINT###:5432/###ZARF_VAR_CONFLUENCE_DB_NAME###"
  driver: org.postgresql.Driver
  credentials:
    secretName: confluence-postgres
    usernameSecretKey: username
    passwordSecretKey: password

monitoring:
  exposeJmxMetrics: true
  jmxExporterInitContainer:
    runAsRoot: false

volumes:
  localHome:
    persistentVolumeClaim:
      create: true
      # storageClassName: your-storage-class-here
      resources:
        requests:
          storage: 10Gi
  sharedHome:
    persistentVolumeClaim:
      create: true # To enable clustering
    nfsPermissionFixer:
      enabled: false
    # mountPath: "/var/atlassian/application-data/shared-home" # for reference, that's the mountPath for the shared home
    # you'll put that in the first screen after selecting clustered.

ingress:
  nginx: false

confluence:
  service:
    type: ClusterIP  # Use this whether doing a standalone server or a clustered setup

  tomcatConfig:
    generateByHelm: true
  seraphConfig:
    generateByHelm: true
  resources:
    container:
      requests:
        cpu: "500m"
        memory: "2Gi"
      limits:
        cpu: "6"
        memory: "6Gi"
    jvm:
      maxHeap: "4g"
  securityContext:
    fsGroup: 2002
    runAsNonRoot: true
    runAsUser: 2002
    runAsGroup: 2002
  containerSecurityContext:
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    runAsUser: 2002
    runAsGroup: 2002

# Clustering related components
# replicaCount: 1 - bring this up manually, one-by-one. TODO: prove it breaks to have all nodes up unclustered before joining them. They certainly must be joined 0, 1, 2, etc.


# TODO: get Synchrony's clustering setup too
