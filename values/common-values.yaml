database:
  type: postgresql
  url: "jdbc:postgresql://###ZARF_VAR_CONFLUENCE_DB_ENDPOINT###:5432/###ZARF_VAR_CONFLUENCE_DB_NAME###"
  driver: org.postgresql.Driver
  credentials:
    secretName: confluence-postgres
    usernameSecretKey: username
    passwordSecretKey: password

monitoring:
  exposeJmxMetrics: true
  jmxExporterInitContainer:
    runAsRoot: false

volumes:
  localHome:
    persistentVolumeClaim:
      create: true
      # storageClassName: your-storage-class-here
      resources:
        requests:
          storage: 10Gi
  sharedHome:
    persistentVolumeClaim:
      create: true # To enable clustering
    nfsPermissionFixer:
      enabled: false
    # mountPath: "/var/atlassian/application-data/shared-home" # for reference, that's the mountPath for the shared home
    # you'll put that in the first screen after selecting clustered.

ingress:
  nginx: false

serviceAccount:
  create: true
  name: confluence
  role:
    create: true

   # Define permissions
   # https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole
   #
  clusterRole:

    # -- Set to 'true' if a ClusterRole should be created, or 'false' if it
    # already exists.
    #
    create: true

    # -- The name of the ClusterRole to be used. If not specified, but
    # the "serviceAccount.clusterRole.create" flag is set to 'true',
    # then the ClusterRole name will be auto-generated.
    #
    name: confluence

confluence:
  service:
    type: ClusterIP  # Use this whether doing a standalone server or a clustered setup
  hazelcastService:
    enabled: true  # Required for clustering
  clustering:
    enabled: true  # Also required to get this stuff to work
  license:  # Convenience to reduce clickops
    secretName: "confluence-license"
    secretKey: "license-key"
  tomcatConfig:
    generateByHelm: true
  seraphConfig:
    generateByHelm: true
  resources:
    container:
      requests:
        cpu: "500m"
        memory: "2Gi"
      limits:
        cpu: "6"
        memory: "6Gi"
    jvm:
      maxHeap: "4g"
  securityContext:
    fsGroup: 2002
    runAsNonRoot: true
    runAsUser: 2002
    runAsGroup: 2002
  containerSecurityContext:
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    runAsUser: 2002
    runAsGroup: 2002

# Clustering related components
# replicaCount: 1 - bring this up manually, one-by-one. TODO: prove it breaks to have all nodes up unclustered before joining them. They certainly must be joined 0, 1, 2, etc.


# TODO: get Synchrony's clustering setup too

# At minimum we support v1.2, may change to support only v1.3: https://github.com/defenseunicorns/uds-core/blob/main/src/istio/chart/values.yaml#L28
  additionalJvmArgs: [ "-Dhttps.protocols=TLSv1.2,TLSv1.3" ]

  additionalCertificates:
    secretName:
    customCmd:
